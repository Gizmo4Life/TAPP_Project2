DISCLAIMER: I say a lot about "idiot-proofing". I promise there are no implications beyond the generally good coding practices this entails.

General:
- I tended to favor readability over absolute efficiency (a few extra method calls here and there; same O(whatever), WAY more readable/usable)

-------------------------------------------------------------------------------

Collider:
	- not a "Collidable" interface
		- allows for do-nothing default implementations of collision-interface methods
		- only override what you need to do; minimizes clutter in "implementing" classes
		- adding a collision-interface method does not require any changes to existing Colliders

Hitbox:
	- "Hitbox hb" is favored over "Hitbox h"
		- won't conflict with "int h; //height". This gets very obnoxious in some places.
		- easier to pluralize: "ArrayList<Hitbox> hbs"
		- more specific at a glance, weird enough letter-combination that it will probably have a consistent meaning
	- Avoid showing data fields to the outside
		- simple idiot-proofing
		- "void collide(Collider c)" instead of "Collider getCollider()"
		- Collider mandatory in constructor, no setter method to change it
		- Bounds are input via points; Hitbox cannot change its position, passing a VectorPoint or LinkedPoint allows for controlled position updates.
	- Hitboxes should double-check the collision during a call to hb1.collide(hb2), and throw an exception if hb1 is not colliding with hb2.
		- simple input validation: catches bugs in HitLayer, catches misuse of these methods from the outside.

HitLayer:
	- must manually call removeHitbox()
		- no good way to decide when a Hitbox is not useful anymore
		- efficiency relies on maintaining a reference to each Hitbox
		- must manually call addHitbox(); slightly more obvious that the hitbox will eventually have to be removed, Hitbox not hidden from the caller
	- should throw an exception when removeHitbox() is called on a Hitbox which was never   added
	- should throw an exception when addHitbox()    is called on a Hitbox which was already added

Point:
	- Point is abstract because...
		- Can pass mutable Point-subclasses into methods as immutable Points; idiot-proofing
		- Quasi-polymorphism between Point subclasses, hides unnecessary details in subclasses.
		- vast differences in subclass intentions
			- VectorPoint is a 2D vector; use it as a "default" or "simple" implementation of Point, keep a reference to it and modify at will.
			- AnchorPoint is a 2D vector specifically made to host LinkedPoints (rotation makes no sense in context of a pure VectorPoint)
			- LinkedPoint is meant to be automatic; minimal manual interaction; make it, then forget about it.

	#--Subclasses--#

	VectorPoint
		- Uses:
			- store a position in space (if you just want a Point implementation, use this)
			- act as a 2D-vector; movement vectors come to mind
		- Key features:
			- mutable
			- easy vector operations

	AnchorPoint
		- Uses:
			- Act like a VectorPoint, serve as an anchor for LinkedPoints
		- Key Features:
			- has a concept of rotation
			- behaves exactly like a VectorPoint in every other way
			- in conjunction with the LinkPoint interface, guarantees that LinkPoints cannot be chained
				- simpler implementation
				- does not omit useful functionality
				- much cleaner and/or more efficient, depending on which alternative you consider

	LinkedPoint
		- Uses
			- Automatically update the position of, for example, the hitbox and graphical representation of an object.
		- Key Features
			- Automatically-updating absolute coordinates; position is constant relative to an AnchorPoint
			- Ability to ignore anchor's rotation
				- hitboxes
				- hud-elements (health bar displayed beside the player entity?)
				- particle effects (particles shouldn't rotate with the player/enemy)
